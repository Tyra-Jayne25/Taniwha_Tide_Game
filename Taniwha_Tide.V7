import pygame
import sys
import random
import math
from fractions import Fraction

# Initialize pygame
pygame.init()
pygame.font.init()

# Constants
WINDOW_WIDTH = 1000
WINDOW_HEIGHT = 720
FPS = 60

# Colors
WHITE = (255, 255, 255)
WATER_BLUE = (0, 105, 148)
SEA_BLUE = (70, 130, 180)
BUTTON_COLOR = (0, 150, 200)
BUTTON_HOVER = (0, 180, 230)
TANIWHA_GREEN = (34, 139, 34)
RED = (255, 50, 50)
GREEN = (0, 255, 0)
BROWN = (139, 69, 19)
PINK = (255, 182, 193)
PURPLE = (128, 0, 128)
YELLOW = (255, 255, 0)
LIGHT_BLUE = (173, 216, 230)
HUT_BROWN = (101, 67, 33)
HUT_ROOF = (60, 40, 20)
PRACTICE_BUTTON_COLOR = (100, 200, 100)
PRACTICE_BUTTON_HOVER = (120, 220, 120)
HUB_BACKGROUND = (50, 80, 120)
THEORY_BACKGROUND = (60, 90, 130)

# Create game window
screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("Taniwha Tide")
clock = pygame.time.Clock()

# Fonts
title_font = pygame.font.SysFont("Arial", 72, bold=True)
button_font = pygame.font.SysFont("Arial", 36)
health_font = pygame.font.SysFont("Arial", 28)
math_font = pygame.font.SysFont("Arial", 24)
question_font = pygame.font.SysFont("Arial", 32, bold=True)
theory_font = pygame.font.SysFont("Arial", 22)

# Game objects
start_button = pygame.Rect(WINDOW_WIDTH//2 - 100, WINDOW_HEIGHT//2 + 50, 200, 60)
practice_button = pygame.Rect(WINDOW_WIDTH//2 + 150, WINDOW_HEIGHT//2 + 50, 80, 80)  # Hut icon button

# Load images
try:
    # Taniwha image with hurt state
    taniwha_img = pygame.image.load("Taniwha.png").convert_alpha()
    taniwha_img = pygame.transform.scale(taniwha_img, (300, 200))  # Larger size
    taniwha_hurt_img = taniwha_img.copy()
    hurt_overlay = pygame.Surface(taniwha_img.get_size(), pygame.SRCALPHA)
    hurt_overlay.fill((255, 0, 0, 128))  # Red with 50% opacity
    taniwha_hurt_img.blit(hurt_overlay, (0, 0), special_flags=pygame.BLEND_MULT)
    
    net_image = pygame.image.load("net_obstacle.png").convert_alpha()
    net_image = pygame.transform.scale(net_image, (90, 90))
    jellyfish_image = pygame.image.load("jelly_obstacle.png").convert_alpha()
    jellyfish_image = pygame.transform.scale(jellyfish_image, (90, 90))
    background_image = pygame.image.load("Lvl1_water_background.png").convert()
    background_image = pygame.transform.scale(background_image, (WINDOW_WIDTH, WINDOW_HEIGHT))
except:
    # Fallback if images not found
    taniwha_img = pygame.Surface((300, 200))
    taniwha_img.fill(TANIWHA_GREEN)
    taniwha_hurt_img = taniwha_img.copy()
    hurt_overlay = pygame.Surface(taniwha_img.get_size())
    hurt_overlay.fill(RED)
    taniwha_hurt_img.blit(hurt_overlay, (0, 0))
    
    net_image = pygame.Surface((90, 90))
    net_image.fill(BROWN)
    jellyfish_image = pygame.Surface((90, 90))
    jellyfish_image.fill(PINK)
    background_image = pygame.Surface((WINDOW_WIDTH, WINDOW_HEIGHT))
    background_image.fill(WATER_BLUE)

taniwha_rect = taniwha_img.get_rect(center=(WINDOW_WIDTH//2, WINDOW_HEIGHT//2 + 150))
taniwha_speed = 5
hurt_timer = 0
HURT_DURATION = 30

# Game state
current_scene = "menu"  # Can be: menu, level1, practice_hub, fractions_practice, algebra_practice
camera_x = 0
lives = 5
game_over = False
user_input = ""
answer_feedback = ""
feedback_timer = 0
math_question_active = False
current_question = None
boost_active = False
boost_timer = 0
boost_duration = 180
current_level = 1
questions_answered = 0
total_questions = 10
level_width = 2200
practice_question_index = 0
show_theory = True  # Toggle between theory and practice

# Practice content - Enhanced with theory sections
fractions_practice = [
    {
        "theory": [
            "What are fractions?",
            "Fractions represent parts of a whole. The top number (numerator) shows how many parts we have.",
            "The bottom number (denominator) shows how many equal parts the whole is divided into.",
            "Example: 1/2 means 1 part out of 2 equal parts (half). 3/4 means 3 parts out of 4 equal parts.",
            "",
            "Types of fractions:",
            "- Proper: numerator < denominator (e.g., 3/5)",
            "- Improper: numerator ≥ denominator (e.g., 7/2)",
            "- Mixed: whole number + fraction (e.g., 2 1/3)"
        ],
        "example": "1/2 + 1/4 = 3/4",
        "explanation": "Find common denominator (4). Convert 1/2 to 2/4. Add numerators: 2/4 + 1/4 = 3/4"
    },
    {
        "theory": [
            "Adding/Subtracting Fractions:",
            "1. Find a common denominator (LCM of denominators)",
            "2. Convert each fraction to equivalent with common denominator",
            "3. Add/subtract numerators, keep denominator same",
            "4. Simplify if possible",
            "",
            "Example: 1/3 + 1/6",
            "Common denominator is 6",
            "1/3 becomes 2/6",
            "2/6 + 1/6 = 3/6 = 1/2"
        ],
        "example": "5/6 - 1/2 = 1/3",
        "explanation": "Common denominator is 6. Convert 1/2 to 3/6. Subtract: 5/6 - 3/6 = 2/6 = 1/3"
    },
    {
        "theory": [
            "Multiplying Fractions:",
            "1. Multiply numerators together",
            "2. Multiply denominators together",
            "3. Simplify the result",
            "",
            "Dividing Fractions:",
            "1. Flip the second fraction (reciprocal)",
            "2. Multiply the fractions",
            "3. Simplify the result",
            "",
            "Example: 2/3 × 3/4 = 6/12 = 1/2",
            "Example: 2/3 ÷ 3/4 = 2/3 × 4/3 = 8/9"
        ],
        "example": "3/4 × 2/3 = 1/2",
        "explanation": "Multiply numerators (3×2=6) and denominators (4×3=12). Simplify 6/12 to 1/2"
    }
]

algebra_practice = [
    {
        "theory": [
            "What is Algebra?",
            "Algebra uses letters (variables) to represent unknown numbers.",
            "The goal is to find the value of the variable that makes the equation true.",
            "",
            "Basic Rules:",
            "1. Whatever you do to one side, do to the other",
            "2. Use inverse operations to isolate the variable",
            "3. Combine like terms when possible"
        ],
        "example": "x + 3 = 7 → x = 4",
        "explanation": "Subtract 3 from both sides: x = 7 - 3"
    },
    {
        "theory": [
            "Solving Equations:",
            "1. Identify the operation being done to the variable",
            "2. Do the opposite (inverse) operation to both sides",
            "3. Simplify both sides",
            "4. Check your solution by substituting back in",
            "",
            "Example: 2x = 10",
            "Divide both sides by 2: x = 5",
            "Check: 2×5 = 10 ✓"
        ],
        "example": "2x = 10 → x = 5",
        "explanation": "Divide both sides by 2: x = 10 ÷ 2"
    },
    {
        "theory": [
            "Multi-step Equations:",
            "1. Simplify both sides if needed (distribute, combine like terms)",
            "2. Move variable terms to one side, constants to other",
            "3. Isolate the variable",
            "",
            "Example: 3x + 2 = 11",
            "Subtract 2: 3x = 9",
            "Divide by 3: x = 3",
            "Check: 3×3 + 2 = 11 ✓"
        ],
        "example": "3x + 2 = 11 → x = 3",
        "explanation": "First subtract 2 from both sides: 3x = 9. Then divide both sides by 3: x = 3"
    }
]

# Practice Hub buttons
practice_hub_buttons = [
    {"rect": pygame.Rect(WINDOW_WIDTH//2 - 200, WINDOW_HEIGHT//2 - 60, 400, 60), "text": "Fractions Practice", "target": "fractions_practice"},
    {"rect": pygame.Rect(WINDOW_WIDTH//2 - 200, WINDOW_HEIGHT//2 + 20, 400, 60), "text": "Algebra Practice", "target": "algebra_practice"},
    {"rect": pygame.Rect(WINDOW_WIDTH//2 - 200, WINDOW_HEIGHT//2 + 100, 400, 60), "text": "Back to Menu", "target": "menu"}
]

# Create animated water ring surface
water_ring_img = pygame.Surface((120, 120), pygame.SRCALPHA)

# Portal
portal_rect = pygame.Rect(level_width - 150, WINDOW_HEIGHT//2 - 75, 120, 150)
portal_active = False

# Generate water rings
def generate_water_rings():
    rings = []
    grid_cols = 4
    grid_rows = 3
    cell_width = (level_width - WINDOW_WIDTH//2) // grid_cols
    cell_height = WINDOW_HEIGHT // grid_rows
    
    positions = []
    for col in range(grid_cols):
        for row in range(grid_rows):
            x = WINDOW_WIDTH//2 + 100 + col * cell_width + random.randint(-100, 100)
            y = 100 + row * cell_height + random.randint(-100, 100)
            positions.append((x, y))
    
    random.shuffle(positions)
    
    questions = [
        {"question": "1/2 + 1/4", "answer_frac": Fraction(3,4)},
        {"question": "2/3 - 1/3", "answer_frac": Fraction(1,3)},
        {"question": "3/4 ÷ 1/2", "answer_frac": Fraction(3,2)},
        {"question": "1/5 × 2/3", "answer_frac": Fraction(2,15)},
        {"question": "Simplify: 4/8", "answer_frac": Fraction(1,2)},
        {"question": "Solve: x + 1/2 = 3/4", "answer_frac": Fraction(1,4)},
        {"question": "2/7 + 3/7", "answer_frac": Fraction(5,7)},
        {"question": "5/6 - 1/2", "answer_frac": Fraction(1,3)},
        {"question": "3/5 × 2/3", "answer_frac": Fraction(2,5)},
        {"question": "Solve: x - 1/3 = 1/6", "answer_frac": Fraction(1,2)}
    ]
    
    for (x, y), q in zip(positions[:10], questions):
        rings.append({
            "rect": pygame.Rect(x, y, 120, 120),
            "question": q["question"],
            "answer_frac": q["answer_frac"],
            "triggered": False,
            "answered": False,
            "animation_offset": random.uniform(0, 2*math.pi)
        })
    return rings

# Generate algebra rings
def generate_algebra_rings():
    rings = []
    grid_cols = 4
    grid_rows = 3
    cell_width = (level_width - WINDOW_WIDTH//2) // grid_cols
    cell_height = WINDOW_HEIGHT // grid_rows
    
    positions = []
    for col in range(grid_cols):
        for row in range(grid_rows):
            x = WINDOW_WIDTH//2 + 100 + col * cell_width + random.randint(-100, 100)
            y = 100 + row * cell_height + random.randint(-100, 100)
            positions.append((x, y))
    
    random.shuffle(positions)
    
    questions = [
        {"question": "Solve: x + 5 = 9", "answer": 4},
        {"question": "Solve: 2x = 10", "answer": 5},
        {"question": "Solve: x - 3 = 7", "answer": 10},
        {"question": "Solve: x/2 = 4", "answer": 8},
        {"question": "Solve: 3x + 2 = 11", "answer": 3},
        {"question": "Solve: 2x - 5 = 7", "answer": 6},
        {"question": "Solve: x/3 + 1 = 4", "answer": 9},
        {"question": "Solve: 4x - 3 = 13", "answer": 4},
        {"question": "Solve: 2(x + 3) = 10", "answer": 2},
        {"question": "Solve: 5x - 2 = 3x + 4", "answer": 3}
    ]
    
    for (x, y), q in zip(positions[:10], questions):
        rings.append({
            "rect": pygame.Rect(x, y, 120, 120),
            "question": q["question"],
            "answer": q["answer"],
            "triggered": False,
            "answered": False,
            "animation_offset": random.uniform(0, 2*math.pi)
        })
    return rings

water_rings = generate_water_rings()
algebra_rings = generate_algebra_rings()

# Generate obstacles
def generate_obstacles():
    obstacles = []
    OB_SIZE = 90
    MIN_DIST_FROM_RING = 200
    MIN_DIST_FROM_OBSTACLE = 160
    MIN_DIST_FROM_PORTAL = 300
    TARGET_COUNT = 15

    for _ in range(TARGET_COUNT):
        placed = False
        attempts = 0
        while not placed and attempts < 50:
            x = random.randint(WINDOW_WIDTH//2 + 200, level_width - OB_SIZE)
            y = random.randint(50, WINDOW_HEIGHT - 50 - OB_SIZE)
            rect = pygame.Rect(x, y, OB_SIZE, OB_SIZE)

            dist_to_spawn = ((rect.centerx - WINDOW_WIDTH//2)**2 + (rect.centery - (WINDOW_HEIGHT//2 + 150))**2)**0.5
            if dist_to_spawn < 400:
                attempts += 1
                continue

            too_close = False
            rings = water_rings if current_level == 1 else algebra_rings
            for ring in rings:
                dx = rect.centerx - ring["rect"].centerx
                dy = rect.centery - ring["rect"].centery
                dist = (dx**2 + dy**2)**0.5
                if dist < MIN_DIST_FROM_RING:
                    too_close = True
                    break
            if too_close:
                attempts += 1
                continue

            dx = rect.centerx - portal_rect.centerx
            dy = rect.centery - portal_rect.centery
            dist = (dx**2 + dy**2)**0.5
            if dist < MIN_DIST_FROM_PORTAL:
                attempts += 1
                continue

            overlap = False
            for _, o_rect in obstacles:
                dx = rect.centerx - o_rect.centerx
                dy = rect.centery - o_rect.centery
                dist = (dx**2 + dy**2)**0.5
                if dist < MIN_DIST_FROM_OBSTACLE:
                    overlap = True
                    break
            if overlap:
                attempts += 1
                continue

            kind = random.choice(["net", "jelly"])
            obstacles.append((kind, rect))
            placed = True

    return obstacles

obstacles = generate_obstacles()

# Drawing functions
def draw_hut_button(rect, hover):
    # Draw hut icon
    base_color = HUT_BROWN
    roof_color = HUT_ROOF
    if hover:
        base_color = tuple(min(c + 30, 255) for c in base_color)
        roof_color = tuple(min(c + 30, 255) for c in roof_color)
    
    # Hut base
    pygame.draw.rect(screen, base_color, pygame.Rect(rect.x + 20, rect.y + 30, 40, 30))
    # Hut roof (triangle)
    pygame.draw.polygon(screen, roof_color, [
        (rect.x + 20, rect.y + 30),
        (rect.x + 60, rect.y + 30),
        (rect.x + 40, rect.y + 10)
    ])
    # Door
    pygame.draw.rect(screen, (70, 40, 10), pygame.Rect(rect.x + 35, rect.y + 40, 10, 20))
    # Window
    pygame.draw.rect(screen, LIGHT_BLUE, pygame.Rect(rect.x + 25, rect.y + 35, 8, 8))
    
    # Label
    label = math_font.render("Practice", True, WHITE)
    screen.blit(label, (rect.x, rect.y + 70))

def draw_menu():
    screen.fill(WATER_BLUE)
    title = title_font.render("Taniwha Tide", True, WHITE)
    screen.blit(title, title.get_rect(center=(WINDOW_WIDTH//2, WINDOW_HEIGHT//2 - 150)))
    
    mouse_pos = pygame.mouse.get_pos()
    
    # Start Game button
    col = BUTTON_HOVER if start_button.collidepoint(mouse_pos) else BUTTON_COLOR
    pygame.draw.rect(screen, col, start_button)
    txt = button_font.render("Start Game", True, WHITE)
    screen.blit(txt, txt.get_rect(center=start_button.center))
    
    # Practice Hub hut button
    hover = practice_button.collidepoint(mouse_pos)
    draw_hut_button(practice_button, hover)

def draw_practice_hub():
    screen.fill(HUB_BACKGROUND)
    title = title_font.render("Practice Hub", True, WHITE)
    screen.blit(title, title.get_rect(center=(WINDOW_WIDTH//2, WINDOW_HEIGHT//2 - 150)))
    
    mouse_pos = pygame.mouse.get_pos()
    for button in practice_hub_buttons:
        col = PRACTICE_BUTTON_HOVER if button["rect"].collidepoint(mouse_pos) else PRACTICE_BUTTON_COLOR
        pygame.draw.rect(screen, col, button["rect"])
        txt = button_font.render(button["text"], True, WHITE)
        screen.blit(txt, txt.get_rect(center=button["rect"].center))

def draw_fractions_practice():
    global show_theory
    current = fractions_practice[practice_question_index]
    
    if show_theory:
        screen.fill(THEORY_BACKGROUND)
        title = title_font.render("Fractions Theory", True, WHITE)
        screen.blit(title, title.get_rect(center=(WINDOW_WIDTH//2, 60)))
        
        # Display theory lines
        for i, line in enumerate(current["theory"]):
            text = theory_font.render(line, True, WHITE)
            screen.blit(text, (50, 120 + i * 30))
    else:
        screen.fill(HUB_BACKGROUND)
        title = title_font.render("Fractions Practice", True, WHITE)
        screen.blit(title, title.get_rect(center=(WINDOW_WIDTH//2, 80)))
        
        example = question_font.render(f"Example: {current['example']}", True, WHITE)
        screen.blit(example, example.get_rect(center=(WINDOW_WIDTH//2, 150)))
        
        # Split explanation into multiple lines
        explanation_lines = current["explanation"].split('\n')
        for i, line in enumerate(explanation_lines):
            text = math_font.render(line, True, WHITE)
            screen.blit(text, (50, 200 + i * 40))
    
    # Navigation buttons with Back to Menu and Toggle Theory/Practice
    back_btn = pygame.Rect(50, WINDOW_HEIGHT - 100, 150, 60)
    next_btn = pygame.Rect(WINDOW_WIDTH - 200, WINDOW_HEIGHT - 100, 150, 60)
    menu_btn = pygame.Rect(WINDOW_WIDTH//2 - 100, WINDOW_HEIGHT - 100, 200, 60)
    toggle_btn = pygame.Rect(WINDOW_WIDTH//2 - 100, WINDOW_HEIGHT - 180, 200, 60)
    
    mouse_pos = pygame.mouse.get_pos()
    
    # Back button (previous example)
    pygame.draw.rect(screen, PRACTICE_BUTTON_HOVER if back_btn.collidepoint(mouse_pos) else PRACTICE_BUTTON_COLOR, back_btn)
    back_txt = button_font.render("Previous", True, WHITE)
    screen.blit(back_txt, back_txt.get_rect(center=back_btn.center))
    
    # Next button (next example)
    pygame.draw.rect(screen, PRACTICE_BUTTON_HOVER if next_btn.collidepoint(mouse_pos) else PRACTICE_BUTTON_COLOR, next_btn)
    next_txt = button_font.render("Next", True, WHITE)
    screen.blit(next_txt, next_txt.get_rect(center=next_btn.center))
    
    # Back to Menu button
    pygame.draw.rect(screen, PRACTICE_BUTTON_HOVER if menu_btn.collidepoint(mouse_pos) else PRACTICE_BUTTON_COLOR, menu_btn)
    menu_txt = button_font.render("Back to Menu", True, WHITE)
    screen.blit(menu_txt, menu_txt.get_rect(center=menu_btn.center))
    
    # Toggle Theory/Practice button
    pygame.draw.rect(screen, PRACTICE_BUTTON_HOVER if toggle_btn.collidepoint(mouse_pos) else PRACTICE_BUTTON_COLOR, toggle_btn)
    toggle_txt = button_font.render("Show Practice" if show_theory else "Show Theory", True, WHITE)
    screen.blit(toggle_txt, toggle_txt.get_rect(center=toggle_btn.center))

def draw_algebra_practice():
    global show_theory
    current = algebra_practice[practice_question_index]
    
    if show_theory:
        screen.fill(THEORY_BACKGROUND)
        title = title_font.render("Algebra Theory", True, WHITE)
        screen.blit(title, title.get_rect(center=(WINDOW_WIDTH//2, 60)))
        
        # Display theory lines
        for i, line in enumerate(current["theory"]):
            text = theory_font.render(line, True, WHITE)
            screen.blit(text, (50, 120 + i * 30))
    else:
        screen.fill(HUB_BACKGROUND)
        title = title_font.render("Algebra Practice", True, WHITE)
        screen.blit(title, title.get_rect(center=(WINDOW_WIDTH//2, 80)))
        
        example = question_font.render(f"Example: {current['example']}", True, WHITE)
        screen.blit(example, example.get_rect(center=(WINDOW_WIDTH//2, 150)))
        
        # Split explanation into multiple lines
        explanation_lines = current["explanation"].split('\n')
        for i, line in enumerate(explanation_lines):
            text = math_font.render(line, True, WHITE)
            screen.blit(text, (50, 200 + i * 40))
    
    # Navigation buttons with Back to Menu and Toggle Theory/Practice
    back_btn = pygame.Rect(50, WINDOW_HEIGHT - 100, 150, 60)
    next_btn = pygame.Rect(WINDOW_WIDTH - 200, WINDOW_HEIGHT - 100, 150, 60)
    menu_btn = pygame.Rect(WINDOW_WIDTH//2 - 100, WINDOW_HEIGHT - 100, 200, 60)
    toggle_btn = pygame.Rect(WINDOW_WIDTH//2 - 100, WINDOW_HEIGHT - 180, 200, 60)
    
    mouse_pos = pygame.mouse.get_pos()
    
    # Back button (previous example)
    pygame.draw.rect(screen, PRACTICE_BUTTON_HOVER if back_btn.collidepoint(mouse_pos) else PRACTICE_BUTTON_COLOR, back_btn)
    back_txt = button_font.render("Previous", True, WHITE)
    screen.blit(back_txt, back_txt.get_rect(center=back_btn.center))
    
    # Next button (next example)
    pygame.draw.rect(screen, PRACTICE_BUTTON_HOVER if next_btn.collidepoint(mouse_pos) else PRACTICE_BUTTON_COLOR, next_btn)
    next_txt = button_font.render("Next", True, WHITE)
    screen.blit(next_txt, next_txt.get_rect(center=next_btn.center))
    
    # Back to Menu button
    pygame.draw.rect(screen, PRACTICE_BUTTON_HOVER if menu_btn.collidepoint(mouse_pos) else PRACTICE_BUTTON_COLOR, menu_btn)
    menu_txt = button_font.render("Back to Menu", True, WHITE)
    screen.blit(menu_txt, menu_txt.get_rect(center=menu_btn.center))
    
    # Toggle Theory/Practice button
    pygame.draw.rect(screen, PRACTICE_BUTTON_HOVER if toggle_btn.collidepoint(mouse_pos) else PRACTICE_BUTTON_COLOR, toggle_btn)
    toggle_txt = button_font.render("Show Practice" if show_theory else "Show Theory", True, WHITE)
    screen.blit(toggle_txt, toggle_txt.get_rect(center=toggle_btn.center))

def draw_health():
    lbl = health_font.render(f"Lives: {lives}", True, RED)
    screen.blit(lbl, (20, 20))
    q_lbl = health_font.render(f"Questions: {questions_answered}/{total_questions}", True, GREEN)
    screen.blit(q_lbl, (20, 60))

def draw_question_popup():
    popup_rect = pygame.Rect(WINDOW_WIDTH//2 - 200, WINDOW_HEIGHT//2 - 100, 400, 200)
    pygame.draw.rect(screen, SEA_BLUE, popup_rect)
    pygame.draw.rect(screen, WHITE, popup_rect, 3)
    
    question_text = question_font.render(current_question["question"], True, WHITE)
    screen.blit(question_text, (WINDOW_WIDTH//2 - question_text.get_width()//2, WINDOW_HEIGHT//2 - 50))
    
    input_text = math_font.render(f"Answer: {user_input}", True, WHITE)
    screen.blit(input_text, (WINDOW_WIDTH//2 - input_text.get_width()//2, WINDOW_HEIGHT//2))
    
    instructions = health_font.render("Press ENTER to submit", True, WHITE)
    screen.blit(instructions, (WINDOW_WIDTH//2 - instructions.get_width()//2, WINDOW_HEIGHT//2 + 50))

def handle_math_and_feedback():
    global feedback_timer, answer_feedback
    if math_question_active and current_question:
        draw_question_popup()
    if answer_feedback and feedback_timer > 0:
        col = GREEN if answer_feedback=="Correct!" else RED
        f = health_font.render(answer_feedback, True, col)
        screen.blit(f, (WINDOW_WIDTH//2 - 60, WINDOW_HEIGHT//2 + 80))
        feedback_timer -= 1
        if feedback_timer <= 0:
            answer_feedback = ""

def draw_game_over():
    screen.fill(SEA_BLUE)
    over = title_font.render("GAME OVER", True, RED)
    screen.blit(over, over.get_rect(center=(WINDOW_WIDTH//2, WINDOW_HEIGHT//2)))

def draw_portal():
    global portal_active
    portal_screen_rect = portal_rect.move(-camera_x, 0)
    all_answered = questions_answered >= total_questions
    portal_active = all_answered
    
    if all_answered:
        pygame.draw.ellipse(screen, YELLOW, portal_screen_rect, 5)
        label = math_font.render("NEXT LEVEL!", True, YELLOW)
    else:
        pygame.draw.ellipse(screen, PURPLE, portal_screen_rect, 5)
        label = math_font.render(f"{total_questions - questions_answered} left", True, PURPLE)
    screen.blit(label, (portal_screen_rect.centerx - label.get_width()//2, portal_screen_rect.centery + 80))

def draw_water_ring_animation(surface, rect, time_offset):
    current_time = pygame.time.get_ticks() * 0.001
    wave_time = current_time + time_offset
    
    temp_surface = pygame.Surface((rect.width, rect.height), pygame.SRCALPHA)
    
    for i in range(1, 4):
        radius = 20 + i * 10 + math.sin(wave_time * 2 + i) * 5
        alpha = 200 - i * 50
        width = max(1, 6 - i)
        
        color = list(LIGHT_BLUE)
        color.append(alpha)
        pygame.draw.circle(temp_surface, color, 
                          (rect.width//2, rect.height//2), 
                          radius, width)
    
    main_radius = 30 + math.sin(wave_time * 3) * 8
    pygame.draw.circle(temp_surface, SEA_BLUE + (150,),
                      (rect.width//2, rect.height//2), 
                      main_radius, 4)
    
    inner_radius = 15 + math.cos(wave_time * 4) * 3
    pygame.draw.circle(temp_surface, LIGHT_BLUE + (200,), 
                      (rect.width//2, rect.height//2), 
                      inner_radius, 2)
    
    screen.blit(temp_surface, rect)

def draw_water_rings():
    rings = water_rings if current_level == 1 else algebra_rings
    for ring in rings:
        r = ring["rect"].move(-camera_x, 0)
        if ring["answered"]:
            draw_water_ring_animation(water_ring_img, r, ring["animation_offset"])
            pygame.draw.line(screen, GREEN, (r.centerx-15, r.centery), (r.centerx, r.centery+15), 4)
            pygame.draw.line(screen, GREEN, (r.centerx, r.centery+15), (r.centerx+25, r.centery-15), 4)
        elif ring["triggered"]:
            size = 120 + int(10 * math.sin(pygame.time.get_ticks() * 0.005))
            temp_img = pygame.Surface((size, size), pygame.SRCALPHA)
            draw_water_ring_animation(temp_img, pygame.Rect(0, 0, size, size), ring["animation_offset"])
            temp_rect = temp_img.get_rect(center=r.center)
            screen.blit(temp_img, temp_rect)
        else:
            draw_water_ring_animation(water_ring_img, r, ring["animation_offset"])

def draw_taniwha():
    global hurt_timer
    taniwha_screen_rect = taniwha_rect.move(-camera_x, 0)
    
    if hurt_timer > 0:
        screen.blit(taniwha_hurt_img, taniwha_screen_rect)
        hurt_timer -= 1
    else:
        screen.blit(taniwha_img, taniwha_screen_rect)

def draw_level():
    if current_level == 1:
        rel_x = camera_x % background_image.get_width()
        screen.blit(background_image, (-rel_x, 0))
        screen.blit(background_image, (-rel_x + background_image.get_width(), 0))
    else:
        screen.fill((50, 50, 80))
        algebra_label = title_font.render("ALGEBRA ZONE", True, WHITE)
        screen.blit(algebra_label, (WINDOW_WIDTH//2 - algebra_label.get_width()//2, 50))
    
    draw_water_rings()
    
    for kind, rect in obstacles:
        r = rect.move(-camera_x, 0)
        if kind == "net":
            screen.blit(net_image, r)
        else:
            screen.blit(jellyfish_image, r)
    
    draw_taniwha()
    draw_health()
    handle_math_and_feedback()
    
    if current_level == 1:
        draw_portal()

# Game logic functions
def handle_movement(keys):
    global camera_x, boost_timer, boost_active, current_scene, current_level, questions_answered
    global obstacles, water_rings, algebra_rings, portal_active
    
    if math_question_active:
        return
    
    speed = taniwha_speed + 3 if boost_active else taniwha_speed

    if keys[pygame.K_LEFT]:
        taniwha_rect.x -= speed
    if keys[pygame.K_RIGHT]:
        taniwha_rect.x += speed
    if keys[pygame.K_UP]:
        taniwha_rect.y -= speed
    if keys[pygame.K_DOWN]:
        taniwha_rect.y += speed

    taniwha_rect.x = max(0, min(taniwha_rect.x, level_width - taniwha_rect.width))
    taniwha_rect.y = max(0, min(taniwha_rect.y, WINDOW_HEIGHT - taniwha_rect.height))

    if current_level == 1 and portal_active:
        portal_screen_rect = portal_rect.move(-camera_x, 0)
        taniwha_screen_rect = taniwha_rect.move(-camera_x, 0)
        if taniwha_screen_rect.colliderect(portal_screen_rect):
            current_level = 2
            questions_answered = 0
            taniwha_rect.x = 100
            taniwha_rect.y = WINDOW_HEIGHT//2
            camera_x = 0
            obstacles = generate_obstacles()

    left_bound = WINDOW_WIDTH * 0.3
    right_bound = WINDOW_WIDTH * 0.7
    cx = taniwha_rect.centerx - camera_x
    if cx > right_bound:
        camera_x = taniwha_rect.centerx - right_bound
    elif cx < left_bound:
        camera_x = taniwha_rect.centerx - left_bound
    camera_x = max(0, min(camera_x, level_width - WINDOW_WIDTH))

    if boost_active:
        boost_timer -= 1
        if boost_timer <= 0:
            boost_active = False

def check_ring_triggers():
    global math_question_active, user_input, answer_feedback, feedback_timer, current_question
    
    rings = water_rings if current_level == 1 else algebra_rings
    for ring in rings:
        ring_screen_rect = ring["rect"].move(-camera_x, 0)
        taniwha_screen_rect = taniwha_rect.move(-camera_x, 0)
        
        if (taniwha_screen_rect.colliderect(ring_screen_rect) and 
            not ring["triggered"] and not ring["answered"]):
            ring["triggered"] = True
            math_question_active = True
            current_question = ring
            user_input = ""
            answer_feedback = ""
            feedback_timer = 0
            break

def check_obstacle_collision():
    global lives, game_over, hurt_timer
    if math_question_active:
        return
    for kind, rect in obstacles:
        r = rect.move(-camera_x, 0)
        if taniwha_rect.colliderect(r):
            lives -= 1
            hurt_timer = HURT_DURATION
            obstacles.remove((kind, rect))
            if lives <= 0:
                game_over = True
            break

def check_answer():
    global answer_feedback, feedback_timer, math_question_active, questions_answered
    global boost_active, boost_timer, lives, game_over, hurt_timer
    
    if current_question:
        current_question["answered"] = True
        
    try:
        if current_level == 1:
            ans_frac = Fraction(user_input)
            correct = ans_frac == current_question["answer_frac"]
        else:
            ans_num = float(user_input)
            correct = abs(ans_num - current_question["answer"]) < 0.001
    except:
        try:
            if current_level == 1:
                ans_frac = Fraction(float(user_input)).limit_denominator()
                correct = ans_frac == current_question["answer_frac"]
            else:
                ans_num = float(user_input)
                correct = abs(ans_num - current_question["answer"]) < 0.001
        except:
            correct = False

    if correct:
        answer_feedback = "Correct!"
        boost_active = True
        boost_timer = boost_duration
        questions_answered += 1
    else:
        answer_feedback = "Incorrect!"
        lives -= 1
        hurt_timer = HURT_DURATION
        if lives <= 0:
            game_over = True

    feedback_timer = FPS * 2
    math_question_active = False

# Main game loop
def main():
    global current_scene, user_input, answer_feedback, math_question_active
    global current_question, lives, game_over, boost_active, boost_timer, camera_x
    global practice_question_index, questions_answered, water_rings, obstacles
    global show_theory

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            elif event.type == pygame.MOUSEBUTTONDOWN:
                if current_scene == "menu":
                    mouse_pos = pygame.mouse.get_pos()
                    if start_button.collidepoint(mouse_pos):
                        current_scene = "level1"
                        # Reset game state
                        lives = 5
                        game_over = False
                        questions_answered = 0
                        water_rings = generate_water_rings()
                        obstacles = generate_obstacles()
                        taniwha_rect.x = WINDOW_WIDTH//2 - 100
                        taniwha_rect.y = WINDOW_HEIGHT//2
                        camera_x = 0
                    elif practice_button.collidepoint(mouse_pos):
                        current_scene = "practice_hub"
                        practice_question_index = 0
                        show_theory = True

                elif current_scene == "practice_hub":
                    mouse_pos = pygame.mouse.get_pos()
                    for button in practice_hub_buttons:
                        if button["rect"].collidepoint(mouse_pos):
                            current_scene = button["target"]
                            practice_question_index = 0
                            show_theory = True

                elif current_scene in ["fractions_practice", "algebra_practice"]:
                    mouse_pos = pygame.mouse.get_pos()
                    back_btn = pygame.Rect(50, WINDOW_HEIGHT - 100, 150, 60)
                    next_btn = pygame.Rect(WINDOW_WIDTH - 200, WINDOW_HEIGHT - 100, 150, 60)
                    menu_btn = pygame.Rect(WINDOW_WIDTH//2 - 100, WINDOW_HEIGHT - 100, 200, 60)
                    toggle_btn = pygame.Rect(WINDOW_WIDTH//2 - 100, WINDOW_HEIGHT - 180, 200, 60)
                    
                    if back_btn.collidepoint(mouse_pos):
                        practice_question_index = max(0, practice_question_index - 1)
                    elif next_btn.collidepoint(mouse_pos):
                        max_index = len(fractions_practice)-1 if current_scene == "fractions_practice" else len(algebra_practice)-1
                        practice_question_index = min(max_index, practice_question_index + 1)
                    elif menu_btn.collidepoint(mouse_pos):
                        current_scene = "menu"
                    elif toggle_btn.collidepoint(mouse_pos):
                        show_theory = not show_theory

            elif event.type == pygame.KEYDOWN and current_scene == "level1" and math_question_active:
                if event.key == pygame.K_RETURN:
                    check_answer()
                elif event.key == pygame.K_BACKSPACE:
                    user_input = user_input[:-1]
                elif event.unicode.isdigit() or event.unicode in ["/", ".", "-"]:
                    user_input += event.unicode

        keys = pygame.key.get_pressed()
        if current_scene == "menu":
            draw_menu()
        elif current_scene == "practice_hub":
            draw_practice_hub()
        elif current_scene == "fractions_practice":
            draw_fractions_practice()
        elif current_scene == "algebra_practice":
            draw_algebra_practice()
        elif current_scene == "level1":
            if game_over:
                draw_game_over()
            else:
                if not math_question_active:
                    handle_movement(keys)
                    check_obstacle_collision()
                check_ring_triggers()
                draw_level()

        pygame.display.flip()
        clock.tick(FPS)

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()