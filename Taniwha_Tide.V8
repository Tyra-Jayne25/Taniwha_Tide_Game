import pygame
import sys
import random
import math
from fractions import Fraction

# Initialize pygame
pygame.init()
pygame.font.init()

# Constants
WINDOW_WIDTH = 1000
WINDOW_HEIGHT = 720
FPS = 60

# Colors
WHITE = (255, 255, 255)
WATER_BLUE = (0, 105, 148)
SEA_BLUE = (70, 130, 180)
BUTTON_COLOR = (0, 150, 200)
BUTTON_HOVER = (0, 180, 230)
TANIWHA_GREEN = (34, 139, 34)
RED = (255, 50, 50)
GREEN = (0, 255, 0)
BROWN = (139, 69, 19)
PINK = (255, 182, 193)
PURPLE = (128, 0, 128)
YELLOW = (255, 255, 0)
LIGHT_BLUE = (173, 216, 230)
HUT_BROWN = (101, 67, 33)
HUT_ROOF = (60, 40, 20)
PRACTICE_BUTTON_COLOR = (100, 200, 100)
PRACTICE_BUTTON_HOVER = (120, 220, 120)
HUB_BACKGROUND = (50, 80, 120)
THEORY_BACKGROUND = (60, 90, 130)

# Create game window
screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("Taniwha Tide")
clock = pygame.time.Clock()

# Fonts
title_font = pygame.font.SysFont("Arial", 72, bold=True)
button_font = pygame.font.SysFont("Arial", 36)
health_font = pygame.font.SysFont("Arial", 28)
math_font = pygame.font.SysFont("Arial", 24)
question_font = pygame.font.SysFont("Arial", 32, bold=True)
theory_font = pygame.font.SysFont("Arial", 22)

# Game objects
start_button = pygame.Rect(WINDOW_WIDTH//2 - 100, WINDOW_HEIGHT//2 + 50, 200, 60)
practice_button = pygame.Rect(WINDOW_WIDTH//2 + 150, WINDOW_HEIGHT//2 + 50, 80, 80)  # Hut icon button

# Load images
try:
    # Taniwha image with hurt state
    taniwha_img = pygame.image.load("Taniwha.png").convert_alpha()
    taniwha_img = pygame.transform.scale(taniwha_img, (300, 200))  # Larger size
    taniwha_hurt_img = taniwha_img.copy()
    hurt_overlay = pygame.Surface(taniwha_img.get_size(), pygame.SRCALPHA)
    hurt_overlay.fill((255, 0, 0, 128))  # Red with 50% opacity
    taniwha_hurt_img.blit(hurt_overlay, (0, 0), special_flags=pygame.BLEND_MULT)
    
    net_image = pygame.image.load("net_obstacle.png").convert_alpha()
    net_image = pygame.transform.scale(net_image, (90, 90))
    jellyfish_image = pygame.image.load("jelly_obstacle.png").convert_alpha()
    jellyfish_image = pygame.transform.scale(jellyfish_image, (90, 90))
    background_image = pygame.image.load("Lvl1_water_background.png").convert()
    background_image = pygame.transform.scale(background_image, (WINDOW_WIDTH, WINDOW_HEIGHT))
except:
    # Fallback if images not found
    taniwha_img = pygame.Surface((300, 200))
    taniwha_img.fill(TANIWHA_GREEN)
    taniwha_hurt_img = taniwha_img.copy()
    hurt_overlay = pygame.Surface(taniwha_img.get_size())
    hurt_overlay.fill(RED)
    taniwha_hurt_img.blit(hurt_overlay, (0, 0))
    
    net_image = pygame.Surface((90, 90))
    net_image.fill(BROWN)
    jellyfish_image = pygame.Surface((90, 90))
    jellyfish_image.fill(PINK)
    background_image = pygame.Surface((WINDOW_WIDTH, WINDOW_HEIGHT))
    background_image.fill(WATER_BLUE)

taniwha_rect = taniwha_img.get_rect(center=(WINDOW_WIDTH//2, WINDOW_HEIGHT//2 + 150))
taniwha_speed = 5
hurt_timer = 0
HURT_DURATION = 30

# Game state
current_scene = "menu"  # Can be: menu, level1, practice_hub, fractions_practice, algebra_practice
camera_x = 0
lives = 5
game_over = False
user_input = ""
answer_feedback = ""
feedback_timer = 0
math_question_active = False
current_question = None
boost_active = False
boost_timer = 0
boost_duration = 180
current_level = 1
questions_answered = 0
total_questions = 10
level_width = 2200
practice_question_index = 0
show_theory = True  # Toggle between theory and practice
level_complete = False

# Enhanced Practice Content
fractions_practice = [
    {
        "theory": [
            "FRACTIONS BASICS",
            "A fraction represents a part of a whole.",
            "Numerator (top number): how many parts we have",
            "Denominator (bottom number): how many equal parts the whole is divided into",
            "",
            "Types of fractions:",
            "- Proper: numerator < denominator (e.g., 3/5)",
            "- Improper: numerator ≥ denominator (e.g., 7/2)",
            "- Mixed: whole number + fraction (e.g., 2 1/3)",
            "- Equivalent: different fractions that represent the same value (e.g., 1/2 = 2/4)"
        ],
        "examples": [
            "Visual Representation:",
            "1/2 = ████████████░░░░░░░░░░ (12 out of 24 squares shaded)",
            "3/4 = ██████████████████░░░░ (18 out of 24 squares shaded)",
            "",
            "Converting between types:",
            "Improper to mixed: 7/2 = 3 1/2 (7 ÷ 2 = 3 with remainder 1)",
            "Mixed to improper: 2 1/3 = (2×3 + 1)/3 = 7/3"
        ],
        "practice": [
            {"question": "What fraction of this shape is shaded? (███░░)", "answer": "3/5"},
            {"question": "Convert 5/2 to a mixed number", "answer": "2 1/2"},
            {"question": "Convert 3 1/4 to an improper fraction", "answer": "13/4"},
            {"question": "Which is larger: 3/4 or 5/8?", "answer": "3/4"},
            {"question": "Find an equivalent fraction to 2/3 with denominator 12", "answer": "8/12"}
        ]
    },
    {
        "theory": [
            "ADDING & SUBTRACTING FRACTIONS",
            "1. Find a common denominator (LCM of denominators)",
            "2. Convert each fraction to equivalent with common denominator",
            "3. Add/subtract numerators, keep denominator same",
            "4. Simplify if possible",
            "",
            "With mixed numbers:",
            "1. Convert to improper fractions",
            "2. Follow steps above",
            "3. Convert back to mixed if needed"
        ],
        "examples": [
            "Simple addition: 1/3 + 1/6 = 2/6 + 1/6 = 3/6 = 1/2",
            "With different denominators: 3/4 + 2/5 = 15/20 + 8/20 = 23/20 = 1 3/20",
            "Subtraction: 7/8 - 1/2 = 7/8 - 4/8 = 3/8",
            "Mixed numbers: 2 1/3 + 1 1/2 = 7/3 + 3/2 = 14/6 + 9/6 = 23/6 = 3 5/6"
        ],
        "practice": [
            {"question": "1/4 + 1/2 = ", "answer": "3/4"},
            {"question": "2/3 - 1/6 = ", "answer": "1/2"},
            {"question": "3/5 + 2/7 = ", "answer": "31/35"},
            {"question": "1 1/2 + 2 1/4 = ", "answer": "3 3/4"},
            {"question": "3 1/3 - 1 3/4 = ", "answer": "1 7/12"}
        ]
    },
    {
        "theory": [
            "MULTIPLYING & DIVIDING FRACTIONS",
            "Multiplying:",
            "1. Multiply numerators together",
            "2. Multiply denominators together",
            "3. Simplify the result",
            "",
            "Dividing:",
            "1. Flip the second fraction (reciprocal)",
            "2. Multiply the fractions",
            "3. Simplify the result",
            "",
            "With mixed numbers:",
            "Convert to improper fractions first"
        ],
        "examples": [
            "Multiplication: 2/3 × 3/4 = (2×3)/(3×4) = 6/12 = 1/2",
            "Division: 2/3 ÷ 3/4 = 2/3 × 4/3 = 8/9",
            "With whole numbers: 3 × 2/5 = 3/1 × 2/5 = 6/5 = 1 1/5",
            "Mixed numbers: 1 1/2 × 2 1/3 = 3/2 × 7/3 = 21/6 = 3 3/6 = 3 1/2"
        ],
        "practice": [
            {"question": "1/2 × 1/3 = ", "answer": "1/6"},
            {"question": "3/4 ÷ 2/5 = ", "answer": "15/8 or 1 7/8"},
            {"question": "5 × 2/3 = ", "answer": "10/3 or 3 1/3"},
            {"question": "2 1/2 × 1 1/5 = ", "answer": "3"},
            {"question": "3/4 ÷ 2 = ", "answer": "3/8"}
        ]
    },
    {
        "theory": [
            "FRACTION WORD PROBLEMS",
            "Key strategies:",
            "1. Identify what the problem is asking",
            "2. Determine which operation to use",
            "3. Convert mixed numbers if needed",
            "4. Perform the calculation",
            "5. Simplify the answer",
            "6. Check if the answer makes sense"
        ],
        "examples": [
            "Problem: A recipe calls for 3/4 cup of flour. You want to make 1/2 of the recipe. How much flour do you need?",
            "Solution: 1/2 × 3/4 = 3/8 cup",
            "",
            "Problem: You have 2 1/2 pizzas and want to divide them equally among 4 friends. How much pizza does each get?",
            "Solution: 2 1/2 ÷ 4 = 5/2 ÷ 4 = 5/2 × 1/4 = 5/8 pizza each"
        ],
        "practice": [
            {"question": "A cake recipe needs 3/4 cup sugar. You're making 1/3 of the recipe. How much sugar?", "answer": "1/4 cup"},
            {"question": "You have 5/8 yard of ribbon and use 1/4 yard. How much is left?", "answer": "3/8 yard"},
            {"question": "A 6 1/2 foot board is cut into 1 1/4 foot pieces. How many pieces?", "answer": "5"},
            {"question": "If 3/5 of students are girls and there are 30 students, how many girls?", "answer": "18"},
            {"question": "You read 1/3 of a book on Monday and 1/4 on Tuesday. What fraction remains?", "answer": "5/12"}
        ]
    }
]

algebra_practice = [
    {
        "theory": [
            "ALGEBRA BASICS",
            "Algebra uses letters (variables) to represent unknown numbers.",
            "The goal is to find the value of the variable that makes the equation true.",
            "",
            "Basic Rules:",
            "1. Whatever you do to one side, do to the other",
            "2. Use inverse operations to isolate the variable",
            "3. Combine like terms when possible",
            "",
            "Key Concepts:",
            "- Like terms: terms with the same variable (3x and 5x)",
            "- Coefficient: number multiplying the variable (in 4x, 4 is coefficient)",
            "- Constant: fixed number (no variable)"
        ],
        "examples": [
            "Simple equation: x + 3 = 7 → x = 7 - 3 → x = 4",
            "With multiplication: 2x = 10 → x = 10 ÷ 2 → x = 5",
            "Combining like terms: 3x + 2x = 15 → 5x = 15 → x = 3",
            "With subtraction: x - 5 = 2 → x = 2 + 5 → x = 7"
        ],
        "practice": [
            {"question": "x + 5 = 12 → x = ", "answer": "7"},
            {"question": "3x = 15 → x = ", "answer": "5"},
            {"question": "x - 4 = 8 → x = ", "answer": "12"},
            {"question": "x/3 = 4 → x = ", "answer": "12"},
            {"question": "2x + 3x = 20 → x = ", "answer": "4"}
        ]
    },
    {
        "theory": [
            "SOLVING MULTI-STEP EQUATIONS",
            "Steps to solve:",
            "1. Simplify both sides (distribute, combine like terms)",
            "2. Move variable terms to one side, constants to other",
            "3. Isolate the variable",
            "4. Check your solution",
            "",
            "Common techniques:",
            "- Distributive property: a(b + c) = ab + ac",
            "- Collecting like terms",
            "- Using inverse operations"
        ],
        "examples": [
            "Example: 3x + 2 = 11 → 3x = 11 - 2 → 3x = 9 → x = 3",
            "With distribution: 2(x + 3) = 10 → 2x + 6 = 10 → 2x = 4 → x = 2",
            "Variables on both sides: 5x - 3 = 2x + 9 → 3x = 12 → x = 4",
            "Multiple steps: 4(x - 2) + 3 = 15 → 4x - 8 + 3 = 15 → 4x - 5 = 15 → 4x = 20 → x = 5"
        ],
        "practice": [
            {"question": "2x + 5 = 17 → x = ", "answer": "6"},
            {"question": "3(x - 2) = 12 → x = ", "answer": "6"},
            {"question": "4x + 3 = 2x + 11 → x = ", "answer": "4"},
            {"question": "5 - 2x = 11 → x = ", "answer": "-3"},
            {"question": "2(3x + 1) = 14 → x = ", "answer": "2"}
        ]
    },
    {
        "theory": [
            "SOLVING EQUATIONS WITH FRACTIONS",
            "Methods:",
            "1. Eliminate fractions by multiplying both sides by LCD",
            "2. Cross-multiplication for proportions",
            "3. Treat fractions carefully when moving terms",
            "",
            "Remember:",
            "- LCD = Least Common Denominator",
            "- When dividing fractions, multiply by reciprocal",
            "- Simplify fractions when possible"
        ],
        "examples": [
            "With fraction coefficients: 1/2x = 8 → x = 8 × 2 → x = 16",
            "Multiple fractions: x/3 + 1/2 = 5/6 → LCD=6 → 2x + 3 = 5 → 2x = 2 → x = 1",
            "Proportion: 3/4 = x/12 → 3×12 = 4x → 36 = 4x → x = 9",
            "Complex: (x + 1)/2 = (x - 1)/3 → 3(x+1) = 2(x-1) → 3x+3 = 2x-2 → x = -5"
        ],
        "practice": [
            {"question": "x/5 = 3 → x = ", "answer": "15"},
            {"question": "2/3x = 8 → x = ", "answer": "12"},
            {"question": "x/2 + 1 = 5 → x = ", "answer": "8"},
            {"question": "3/4 = x/16 → x = ", "answer": "12"},
            {"question": "(x + 2)/3 = (x - 1)/2 → x = ", "answer": "7"}
        ]
    },
    {
        "theory": [
            "ALGEBRA WORD PROBLEMS",
            "Problem-solving approach:",
            "1. Read carefully and identify what's being asked",
            "2. Define variables for unknowns",
            "3. Translate words into equations",
            "4. Solve the equation",
            "5. Check if answer makes sense",
            "",
            "Common problem types:",
            "- Number problems",
            "- Age problems",
            "- Distance-rate-time",
            "- Geometry applications"
        ],
        "examples": [
            "Number problem: If 5 is added to twice a number, the result is 17. Find the number.",
            "Solution: Let x = number → 2x + 5 = 17 → 2x = 12 → x = 6",
            "",
            "Age problem: John is twice as old as Mary. In 5 years, the sum of their ages will be 40. Find current ages.",
            "Solution: Let Mary's age = x, John's = 2x → (x+5)+(2x+5)=40 → 3x+10=40 → 3x=30 → x=10",
            "Mary is 10, John is 20"
        ],
        "practice": [
            {"question": "A number plus 8 is 15. What's the number?", "answer": "7"},
            {"question": "Twice a number minus 5 is 11. Find the number.", "answer": "8"},
            {"question": "The sum of three consecutive integers is 36. Find them.", "answer": "11,12,13"},
            {"question": "A rectangle's length is 3 more than width. Perimeter is 26. Find dimensions.", "answer": "5,8"},
            {"question": "Sara is twice as old as Joe. 5 years ago she was 3 times his age. Find current ages.", "answer": "20,10"}
        ]
    }
]

# Practice Hub buttons
practice_hub_buttons = [
    {"rect": pygame.Rect(WINDOW_WIDTH//2 - 200, WINDOW_HEIGHT//2 - 60, 400, 60), "text": "Fractions Practice", "target": "fractions_practice"},
    {"rect": pygame.Rect(WINDOW_WIDTH//2 - 200, WINDOW_HEIGHT//2 + 20, 400, 60), "text": "Algebra Practice", "target": "algebra_practice"},
    {"rect": pygame.Rect(WINDOW_WIDTH//2 - 200, WINDOW_HEIGHT//2 + 100, 400, 60), "text": "Back to Menu", "target": "menu"}
]

# Create animated water ring surface
water_ring_img = pygame.Surface((120, 120), pygame.SRCALPHA)

# Portal
portal_rect = pygame.Rect(level_width - 150, WINDOW_HEIGHT//2 - 75, 120, 150)
portal_active = False

# Generate water rings
def generate_water_rings():
    rings = []
    grid_cols = 4
    grid_rows = 3
    cell_width = (level_width - WINDOW_WIDTH//2) // grid_cols
    cell_height = WINDOW_HEIGHT // grid_rows
    
    positions = []
    for col in range(grid_cols):
        for row in range(grid_rows):
            x = WINDOW_WIDTH//2 + 100 + col * cell_width + random.randint(-100, 100)
            y = 100 + row * cell_height + random.randint(-100, 100)
            positions.append((x, y))
    
    random.shuffle(positions)
    
    questions = [
        {"question": "1/2 + 1/4", "answer_frac": Fraction(3,4)},
        {"question": "2/3 - 1/3", "answer_frac": Fraction(1,3)},
        {"question": "3/4 ÷ 1/2", "answer_frac": Fraction(3,2)},
        {"question": "1/5 × 2/3", "answer_frac": Fraction(2,15)},
        {"question": "Simplify: 4/8", "answer_frac": Fraction(1,2)},
        {"question": "Solve: x + 1/2 = 3/4", "answer_frac": Fraction(1,4)},
        {"question": "2/7 + 3/7", "answer_frac": Fraction(5,7)},
        {"question": "5/6 - 1/2", "answer_frac": Fraction(1,3)},
        {"question": "3/5 × 2/3", "answer_frac": Fraction(2,5)},
        {"question": "Solve: x - 1/3 = 1/6", "answer_frac": Fraction(1,2)}
    ]
    
    for (x, y), q in zip(positions[:10], questions):
        rings.append({
            "rect": pygame.Rect(x, y, 120, 120),
            "question": q["question"],
            "answer_frac": q["answer_frac"],
            "triggered": False,
            "answered": False,
            "animation_offset": random.uniform(0, 2*math.pi)
        })
    return rings

# Generate algebra rings
def generate_algebra_rings():
    rings = []
    grid_cols = 4
    grid_rows = 3
    cell_width = (level_width - WINDOW_WIDTH//2) // grid_cols
    cell_height = WINDOW_HEIGHT // grid_rows
    
    positions = []
    for col in range(grid_cols):
        for row in range(grid_rows):
            x = WINDOW_WIDTH//2 + 100 + col * cell_width + random.randint(-100, 100)
            y = 100 + row * cell_height + random.randint(-100, 100)
            positions.append((x, y))
    
    random.shuffle(positions)
    
    questions = [
        {"question": "Solve: x + 5 = 9", "answer": 4},
        {"question": "Solve: 2x = 10", "answer": 5},
        {"question": "Solve: x - 3 = 7", "answer": 10},
        {"question": "Solve: x/2 = 4", "answer": 8},
        {"question": "Solve: 3x + 2 = 11", "answer": 3},
        {"question": "Solve: 2x - 5 = 7", "answer": 6},
        {"question": "Solve: x/3 + 1 = 4", "answer": 9},
        {"question": "Solve: 4x - 3 = 13", "answer": 4},
        {"question": "Solve: 2(x + 3) = 10", "answer": 2},
        {"question": "Solve: 5x - 2 = 3x + 4", "answer": 3}
    ]
    
    for (x, y), q in zip(positions[:10], questions):
        rings.append({
            "rect": pygame.Rect(x, y, 120, 120),
            "question": q["question"],
            "answer": q["answer"],
            "triggered": False,
            "answered": False,
            "animation_offset": random.uniform(0, 2*math.pi)
        })
    return rings

water_rings = generate_water_rings()
algebra_rings = generate_algebra_rings()

# Generate obstacles
def generate_obstacles():
    obstacles = []
    OB_SIZE = 90
    MIN_DIST_FROM_RING = 200
    MIN_DIST_FROM_OBSTACLE = 160
    MIN_DIST_FROM_PORTAL = 300
    TARGET_COUNT = 15

    for _ in range(TARGET_COUNT):
        placed = False
        attempts = 0
        while not placed and attempts < 50:
            x = random.randint(WINDOW_WIDTH//2 + 200, level_width - OB_SIZE)
            y = random.randint(50, WINDOW_HEIGHT - 50 - OB_SIZE)
            rect = pygame.Rect(x, y, OB_SIZE, OB_SIZE)

            dist_to_spawn = ((rect.centerx - WINDOW_WIDTH//2)**2 + (rect.centery - (WINDOW_HEIGHT//2 + 150))**2)**0.5
            if dist_to_spawn < 400:
                attempts += 1
                continue

            too_close = False
            rings = water_rings if current_level == 1 else algebra_rings
            for ring in rings:
                dx = rect.centerx - ring["rect"].centerx
                dy = rect.centery - ring["rect"].centery
                dist = (dx**2 + dy**2)**0.5
                if dist < MIN_DIST_FROM_RING:
                    too_close = True
                    break
            if too_close:
                attempts += 1
                continue

            dx = rect.centerx - portal_rect.centerx
            dy = rect.centery - portal_rect.centery
            dist = (dx**2 + dy**2)**0.5
            if dist < MIN_DIST_FROM_PORTAL:
                attempts += 1
                continue

            overlap = False
            for _, o_rect in obstacles:
                dx = rect.centerx - o_rect.centerx
                dy = rect.centery - o_rect.centery
                dist = (dx**2 + dy**2)**0.5
                if dist < MIN_DIST_FROM_OBSTACLE:
                    overlap = True
                    break
            if overlap:
                attempts += 1
                continue

            kind = random.choice(["net", "jelly"])
            obstacles.append((kind, rect))
            placed = True

    return obstacles

obstacles = generate_obstacles()

# Drawing functions
def draw_hut_button(rect, hover):
    # Draw hut icon
    base_color = HUT_BROWN
    roof_color = HUT_ROOF
    if hover:
        base_color = tuple(min(c + 30, 255) for c in base_color)
        roof_color = tuple(min(c + 30, 255) for c in roof_color)
    
    # Hut base
    pygame.draw.rect(screen, base_color, pygame.Rect(rect.x + 20, rect.y + 30, 40, 30))
    # Hut roof (triangle)
    pygame.draw.polygon(screen, roof_color, [
        (rect.x + 20, rect.y + 30),
        (rect.x + 60, rect.y + 30),
        (rect.x + 40, rect.y + 10)
    ])
    # Door
    pygame.draw.rect(screen, (70, 40, 10), pygame.Rect(rect.x + 35, rect.y + 40, 10, 20))
    # Window
    pygame.draw.rect(screen, LIGHT_BLUE, pygame.Rect(rect.x + 25, rect.y + 35, 8, 8))
    
    # Label
    label = math_font.render("Practice", True, WHITE)
    screen.blit(label, (rect.x, rect.y + 70))

def draw_menu():
    screen.fill(WATER_BLUE)
    title = title_font.render("Taniwha Tide", True, WHITE)
    screen.blit(title, title.get_rect(center=(WINDOW_WIDTH//2, WINDOW_HEIGHT//2 - 150)))
    
    mouse_pos = pygame.mouse.get_pos()
    
    # Start Game button
    col = BUTTON_HOVER if start_button.collidepoint(mouse_pos) else BUTTON_COLOR
    pygame.draw.rect(screen, col, start_button)
    txt = button_font.render("Start Game", True, WHITE)
    screen.blit(txt, txt.get_rect(center=start_button.center))
    
    # Practice Hub hut button
    hover = practice_button.collidepoint(mouse_pos)
    draw_hut_button(practice_button, hover)

def draw_practice_hub():
    screen.fill(HUB_BACKGROUND)
    title = title_font.render("Practice Hub", True, WHITE)
    screen.blit(title, title.get_rect(center=(WINDOW_WIDTH//2, WINDOW_HEIGHT//2 - 150)))
    
    mouse_pos = pygame.mouse.get_pos()
    for button in practice_hub_buttons:
        col = PRACTICE_BUTTON_HOVER if button["rect"].collidepoint(mouse_pos) else PRACTICE_BUTTON_COLOR
        pygame.draw.rect(screen, col, button["rect"])
        txt = button_font.render(button["text"], True, WHITE)
        screen.blit(txt, txt.get_rect(center=button["rect"].center))

def draw_fractions_practice():
    global show_theory
    current = fractions_practice[practice_question_index]
    
    if show_theory:
        screen.fill(THEORY_BACKGROUND)
        title = title_font.render("Fractions Practice", True, WHITE)
        screen.blit(title, title.get_rect(center=(WINDOW_WIDTH//2, 40)))
        
        # Display theory lines
        y_pos = 100
        for line in current["theory"]:
            text = theory_font.render(line, True, WHITE)
            screen.blit(text, (50, y_pos))
            y_pos += 30
        
        # Display examples if they exist
        if "examples" in current:
            y_pos += 20
            examples_title = button_font.render("Examples:", True, YELLOW)
            screen.blit(examples_title, (50, y_pos))
            y_pos += 40
            
            for example in current["examples"]:
                text = math_font.render(example, True, LIGHT_BLUE)
                screen.blit(text, (70, y_pos))
                y_pos += 30
    else:
        screen.fill(HUB_BACKGROUND)
        title = title_font.render("Fractions Practice Problems", True, WHITE)
        screen.blit(title, title.get_rect(center=(WINDOW_WIDTH//2, 60)))
        
        y_pos = 120
        for problem in current["practice"]:
            # Draw question
            question_text = math_font.render(problem["question"], True, WHITE)
            screen.blit(question_text, (100, y_pos))
            
            # Draw answer (initially hidden, revealed on hover)
            answer_text = math_font.render(f"Answer: {problem['answer']}", True, GREEN)
            answer_rect = pygame.Rect(600, y_pos, answer_text.get_width(), answer_text.get_height())
            
            # Check if mouse is hovering over this question
            mouse_pos = pygame.mouse.get_pos()
            if answer_rect.collidepoint(mouse_pos):
                screen.blit(answer_text, (600, y_pos))
            else:
                hidden_answer = math_font.render("(hover to reveal)", True, (150, 150, 150))
                screen.blit(hidden_answer, (600, y_pos))
            
            y_pos += 50
    
    # Navigation buttons
    draw_practice_navigation_buttons()

def draw_algebra_practice():
    global show_theory
    current = algebra_practice[practice_question_index]
    
    if show_theory:
        screen.fill(THEORY_BACKGROUND)
        title = title_font.render("Algebra Practice", True, WHITE)
        screen.blit(title, title.get_rect(center=(WINDOW_WIDTH//2, 40)))
        
        # Display theory lines
        y_pos = 100
        for line in current["theory"]:
            text = theory_font.render(line, True, WHITE)
            screen.blit(text, (50, y_pos))
            y_pos += 30
        
        # Display examples if they exist
        if "examples" in current:
            y_pos += 20
            examples_title = button_font.render("Examples:", True, YELLOW)
            screen.blit(examples_title, (50, y_pos))
            y_pos += 40
            
            for example in current["examples"]:
                text = math_font.render(example, True, LIGHT_BLUE)
                screen.blit(text, (70, y_pos))
                y_pos += 30
    else:
        screen.fill(HUB_BACKGROUND)
        title = title_font.render("Algebra Practice Problems", True, WHITE)
        screen.blit(title, title.get_rect(center=(WINDOW_WIDTH//2, 60)))
        
        y_pos = 120
        for problem in current["practice"]:
            # Draw question
            question_text = math_font.render(problem["question"], True, WHITE)
            screen.blit(question_text, (100, y_pos))
            
            # Draw answer (initially hidden, revealed on hover)
            answer_text = math_font.render(f"Answer: {problem['answer']}", True, GREEN)
            answer_rect = pygame.Rect(600, y_pos, answer_text.get_width(), answer_text.get_height())
            
            # Check if mouse is hovering over this question
            mouse_pos = pygame.mouse.get_pos()
            if answer_rect.collidepoint(mouse_pos):
                screen.blit(answer_text, (600, y_pos))
            else:
                hidden_answer = math_font.render("(hover to reveal)", True, (150, 150, 150))
                screen.blit(hidden_answer, (600, y_pos))
            
            y_pos += 50
    
    # Navigation buttons
    draw_practice_navigation_buttons()

def draw_practice_navigation_buttons():
    back_btn = pygame.Rect(50, WINDOW_HEIGHT - 100, 150, 60)
    next_btn = pygame.Rect(WINDOW_WIDTH - 200, WINDOW_HEIGHT - 100, 150, 60)
    menu_btn = pygame.Rect(WINDOW_WIDTH//2 - 100, WINDOW_HEIGHT - 100, 200, 60)
    toggle_btn = pygame.Rect(WINDOW_WIDTH//2 - 100, WINDOW_HEIGHT - 180, 200, 60)
    
    mouse_pos = pygame.mouse.get_pos()
    
    # Back button (previous section)
    pygame.draw.rect(screen, PRACTICE_BUTTON_HOVER if back_btn.collidepoint(mouse_pos) else PRACTICE_BUTTON_COLOR, back_btn)
    back_txt = button_font.render("Previous", True, WHITE)
    screen.blit(back_txt, back_txt.get_rect(center=back_btn.center))
    
    # Next button (only show if there is a next section)
    current_practice = fractions_practice if current_scene == "fractions_practice" else algebra_practice
    max_index = len(current_practice)-1
    if practice_question_index < max_index:
        pygame.draw.rect(screen, PRACTICE_BUTTON_HOVER if next_btn.collidepoint(mouse_pos) else PRACTICE_BUTTON_COLOR, next_btn)
        next_txt = button_font.render("Next", True, WHITE)
        screen.blit(next_txt, next_txt.get_rect(center=next_btn.center))
    
    # Back to Menu button
    pygame.draw.rect(screen, PRACTICE_BUTTON_HOVER if menu_btn.collidepoint(mouse_pos) else PRACTICE_BUTTON_COLOR, menu_btn)
    menu_txt = button_font.render("Back to Menu", True, WHITE)
    screen.blit(menu_txt, menu_txt.get_rect(center=menu_btn.center))
    
    # Toggle Theory/Practice button
    pygame.draw.rect(screen, PRACTICE_BUTTON_HOVER if toggle_btn.collidepoint(mouse_pos) else PRACTICE_BUTTON_COLOR, toggle_btn)
    toggle_txt = button_font.render("Show Problems" if show_theory else "Show Theory", True, WHITE)
    screen.blit(toggle_txt, toggle_txt.get_rect(center=toggle_btn.center))

def draw_health():
    lbl = health_font.render(f"Lives: {lives}", True, RED)
    screen.blit(lbl, (20, 20))
    q_lbl = health_font.render(f"Questions: {questions_answered}/{total_questions}", True, GREEN)
    screen.blit(q_lbl, (20, 60))

def draw_question_popup():
    popup_rect = pygame.Rect(WINDOW_WIDTH//2 - 200, WINDOW_HEIGHT//2 - 100, 400, 200)
    pygame.draw.rect(screen, SEA_BLUE, popup_rect)
    pygame.draw.rect(screen, WHITE, popup_rect, 3)
    
    question_text = question_font.render(current_question["question"], True, WHITE)
    screen.blit(question_text, (WINDOW_WIDTH//2 - question_text.get_width()//2, WINDOW_HEIGHT//2 - 50))
    
    input_text = math_font.render(f"Answer: {user_input}", True, WHITE)
    screen.blit(input_text, (WINDOW_WIDTH//2 - input_text.get_width()//2, WINDOW_HEIGHT//2))
    
    instructions = health_font.render("Press ENTER to submit", True, WHITE)
    screen.blit(instructions, (WINDOW_WIDTH//2 - instructions.get_width()//2, WINDOW_HEIGHT//2 + 50))

def handle_math_and_feedback():
    global feedback_timer, answer_feedback
    if math_question_active and current_question:
        draw_question_popup()
    if answer_feedback and feedback_timer > 0:
        col = GREEN if answer_feedback=="Correct!" else RED
        f = health_font.render(answer_feedback, True, col)
        screen.blit(f, (WINDOW_WIDTH//2 - 60, WINDOW_HEIGHT//2 + 80))
        feedback_timer -= 1
        if feedback_timer <= 0:
            answer_feedback = ""

def draw_game_over():
    screen.fill(SEA_BLUE)
    over = title_font.render("GAME OVER", True, RED)
    screen.blit(over, over.get_rect(center=(WINDOW_WIDTH//2, WINDOW_HEIGHT//2)))
    
    # Replay option buttons
    yes_btn = pygame.Rect(WINDOW_WIDTH//2 - 150, WINDOW_HEIGHT//2 + 100, 120, 60)
    no_btn = pygame.Rect(WINDOW_WIDTH//2 + 30, WINDOW_HEIGHT//2 + 100, 120, 60)
    
    mouse_pos = pygame.mouse.get_pos()
    
    pygame.draw.rect(screen, GREEN if yes_btn.collidepoint(mouse_pos) else (0, 200, 0), yes_btn)
    pygame.draw.rect(screen, RED if no_btn.collidepoint(mouse_pos) else (200, 0, 0), no_btn)
    
    yes_txt = button_font.render("Yes", True, WHITE)
    no_txt = button_font.render("No", True, WHITE)
    
    screen.blit(yes_txt, (yes_btn.centerx - yes_txt.get_width()//2, yes_btn.centery - yes_txt.get_height()//2))
    screen.blit(no_txt, (no_btn.centerx - no_txt.get_width()//2, no_btn.centery - no_txt.get_height()//2))
    
    prompt = button_font.render("Play again?", True, WHITE)
    screen.blit(prompt, (WINDOW_WIDTH//2 - prompt.get_width()//2, WINDOW_HEIGHT//2 + 50))
    
    return yes_btn, no_btn

def draw_level_complete():
    screen.fill(SEA_BLUE)
    complete = title_font.render("LEVEL COMPLETE!", True, GREEN)
    screen.blit(complete, complete.get_rect(center=(WINDOW_WIDTH//2, WINDOW_HEIGHT//2 - 50)))
    
    if current_level == 2:
        congrats = button_font.render("Congratulations! You finished the game!", True, WHITE)
        screen.blit(congrats, (WINDOW_WIDTH//2 - congrats.get_width()//2, WINDOW_HEIGHT//2 + 20))
    
    # Replay option buttons
    yes_btn = pygame.Rect(WINDOW_WIDTH//2 - 150, WINDOW_HEIGHT//2 + 100, 120, 60)
    no_btn = pygame.Rect(WINDOW_WIDTH//2 + 30, WINDOW_HEIGHT//2 + 100, 120, 60)
    
    mouse_pos = pygame.mouse.get_pos()
    
    pygame.draw.rect(screen, GREEN if yes_btn.collidepoint(mouse_pos) else (0, 200, 0), yes_btn)
    pygame.draw.rect(screen, RED if no_btn.collidepoint(mouse_pos) else (200, 0, 0), no_btn)
    
    yes_txt = button_font.render("Yes", True, WHITE)
    no_txt = button_font.render("No", True, WHITE)
    
    screen.blit(yes_txt, (yes_btn.centerx - yes_txt.get_width()//2, yes_btn.centery - yes_txt.get_height()//2))
    screen.blit(no_txt, (no_btn.centerx - no_txt.get_width()//2, no_btn.centery - no_txt.get_height()//2))
    
    prompt = button_font.render("Play again?", True, WHITE)
    screen.blit(prompt, (WINDOW_WIDTH//2 - prompt.get_width()//2, WINDOW_HEIGHT//2 + 50))
    
    return yes_btn, no_btn

def draw_portal():
    global portal_active
    portal_screen_rect = portal_rect.move(-camera_x, 0)
    all_answered = questions_answered >= total_questions
    portal_active = all_answered
    
    if all_answered:
        pygame.draw.ellipse(screen, YELLOW, portal_screen_rect, 5)
        label = math_font.render("NEXT LEVEL!", True, YELLOW)
    else:
        pygame.draw.ellipse(screen, PURPLE, portal_screen_rect, 5)
        label = math_font.render(f"{total_questions - questions_answered} left", True, PURPLE)
    screen.blit(label, (portal_screen_rect.centerx - label.get_width()//2, portal_screen_rect.centery + 80))

def draw_water_ring_animation(surface, rect, time_offset):
    current_time = pygame.time.get_ticks() * 0.001
    wave_time = current_time + time_offset
    
    temp_surface = pygame.Surface((rect.width, rect.height), pygame.SRCALPHA)
    
    for i in range(1, 4):
        radius = 20 + i * 10 + math.sin(wave_time * 2 + i) * 5
        alpha = 200 - i * 50
        width = max(1, 6 - i)
        
        color = list(LIGHT_BLUE)
        color.append(alpha)
        pygame.draw.circle(temp_surface, color, 
                          (rect.width//2, rect.height//2), 
                          radius, width)
    
    main_radius = 30 + math.sin(wave_time * 3) * 8
    pygame.draw.circle(temp_surface, SEA_BLUE + (150,),
                      (rect.width//2, rect.height//2), 
                      main_radius, 4)
    
    inner_radius = 15 + math.cos(wave_time * 4) * 3
    pygame.draw.circle(temp_surface, LIGHT_BLUE + (200,), 
                      (rect.width//2, rect.height//2), 
                      inner_radius, 2)
    
    screen.blit(temp_surface, rect)

def draw_water_rings():
    rings = water_rings if current_level == 1 else algebra_rings
    for ring in rings:
        r = ring["rect"].move(-camera_x, 0)
        if ring["answered"]:
            draw_water_ring_animation(water_ring_img, r, ring["animation_offset"])
            pygame.draw.line(screen, GREEN, (r.centerx-15, r.centery), (r.centerx, r.centery+15), 4)
            pygame.draw.line(screen, GREEN, (r.centerx, r.centery+15), (r.centerx+25, r.centery-15), 4)
        elif ring["triggered"]:
            size = 120 + int(10 * math.sin(pygame.time.get_ticks() * 0.005))
            temp_img = pygame.Surface((size, size), pygame.SRCALPHA)
            draw_water_ring_animation(temp_img, pygame.Rect(0, 0, size, size), ring["animation_offset"])
            temp_rect = temp_img.get_rect(center=r.center)
            screen.blit(temp_img, temp_rect)
        else:
            draw_water_ring_animation(water_ring_img, r, ring["animation_offset"])

def draw_taniwha():
    global hurt_timer
    taniwha_screen_rect = taniwha_rect.move(-camera_x, 0)
    
    if hurt_timer > 0:
        screen.blit(taniwha_hurt_img, taniwha_screen_rect)
        hurt_timer -= 1
    else:
        screen.blit(taniwha_img, taniwha_screen_rect)

def draw_level():
    if current_level == 1:
        rel_x = camera_x % background_image.get_width()
        screen.blit(background_image, (-rel_x, 0))
        screen.blit(background_image, (-rel_x + background_image.get_width(), 0))
    else:
        screen.fill((50, 50, 80))
        algebra_label = title_font.render("ALGEBRA ZONE", True, WHITE)
        screen.blit(algebra_label, (WINDOW_WIDTH//2 - algebra_label.get_width()//2, 50))
    
    draw_water_rings()
    
    for kind, rect in obstacles:
        r = rect.move(-camera_x, 0)
        if kind == "net":
            screen.blit(net_image, r)
        else:
            screen.blit(jellyfish_image, r)
    
    draw_taniwha()
    draw_health()
    handle_math_and_feedback()
    
    if current_level == 1:
        draw_portal()

# Game logic functions
def handle_movement(keys):
    global camera_x, boost_timer, boost_active, current_scene, current_level, questions_answered
    global obstacles, water_rings, algebra_rings, portal_active, level_complete
    
    if math_question_active or game_over or level_complete:
        return
    
    speed = taniwha_speed + 3 if boost_active else taniwha_speed

    if keys[pygame.K_LEFT]:
        taniwha_rect.x -= speed
    if keys[pygame.K_RIGHT]:
        taniwha_rect.x += speed
    if keys[pygame.K_UP]:
        taniwha_rect.y -= speed
    if keys[pygame.K_DOWN]:
        taniwha_rect.y += speed

    taniwha_rect.x = max(0, min(taniwha_rect.x, level_width - taniwha_rect.width))
    taniwha_rect.y = max(0, min(taniwha_rect.y, WINDOW_HEIGHT - taniwha_rect.height))

    if current_level == 1 and portal_active:
        portal_screen_rect = portal_rect.move(-camera_x, 0)
        taniwha_screen_rect = taniwha_rect.move(-camera_x, 0)
        if taniwha_screen_rect.colliderect(portal_screen_rect):
            current_level = 2
            questions_answered = 0
            taniwha_rect.x = 100
            taniwha_rect.y = WINDOW_HEIGHT//2
            camera_x = 0
            obstacles = generate_obstacles()
    elif current_level == 2 and questions_answered >= total_questions:
        level_complete = True

    left_bound = WINDOW_WIDTH * 0.3
    right_bound = WINDOW_WIDTH * 0.7
    cx = taniwha_rect.centerx - camera_x
    if cx > right_bound:
        camera_x = taniwha_rect.centerx - right_bound
    elif cx < left_bound:
        camera_x = taniwha_rect.centerx - left_bound
    camera_x = max(0, min(camera_x, level_width - WINDOW_WIDTH))

    if boost_active:
        boost_timer -= 1
        if boost_timer <= 0:
            boost_active = False

def check_ring_triggers():
    global math_question_active, user_input, answer_feedback, feedback_timer, current_question
    
    rings = water_rings if current_level == 1 else algebra_rings
    for ring in rings:
        ring_screen_rect = ring["rect"].move(-camera_x, 0)
        taniwha_screen_rect = taniwha_rect.move(-camera_x, 0)
        
        if (taniwha_screen_rect.colliderect(ring_screen_rect) and 
            not ring["triggered"] and not ring["answered"]):
            ring["triggered"] = True
            math_question_active = True
            current_question = ring
            user_input = ""
            answer_feedback = ""
            feedback_timer = 0
            break

def check_obstacle_collision():
    global lives, game_over, hurt_timer
    if math_question_active:
        return
    for kind, rect in obstacles:
        r = rect.move(-camera_x, 0)
        if taniwha_rect.colliderect(r):
            lives -= 1
            hurt_timer = HURT_DURATION
            obstacles.remove((kind, rect))
            if lives <= 0:
                game_over = True
            break

def check_answer():
    global answer_feedback, feedback_timer, math_question_active, questions_answered
    global boost_active, boost_timer, lives, game_over, hurt_timer
    
    if current_question:
        current_question["answered"] = True
        
    try:
        if current_level == 1:
            ans_frac = Fraction(user_input)
            correct = ans_frac == current_question["answer_frac"]
        else:
            ans_num = float(user_input)
            correct = abs(ans_num - current_question["answer"]) < 0.001
    except:
        try:
            if current_level == 1:
                ans_frac = Fraction(float(user_input)).limit_denominator()
                correct = ans_frac == current_question["answer_frac"]
            else:
                ans_num = float(user_input)
                correct = abs(ans_num - current_question["answer"]) < 0.001
        except:
            correct = False

    if correct:
        answer_feedback = "Correct!"
        boost_active = True
        boost_timer = boost_duration
        questions_answered += 1
    else:
        answer_feedback = "Incorrect!"
        lives -= 1
        hurt_timer = HURT_DURATION
        if lives <= 0:
            game_over = True

    feedback_timer = FPS * 2
    math_question_active = False

def reset_game():
    global lives, game_over, questions_answered, water_rings, obstacles
    global taniwha_rect, camera_x, current_level, level_complete
    
    lives = 5
    game_over = False
    level_complete = False
    questions_answered = 0
    water_rings = generate_water_rings()
    obstacles = generate_obstacles()
    taniwha_rect.x = WINDOW_WIDTH//2 - 100
    taniwha_rect.y = WINDOW_HEIGHT//2
    camera_x = 0
    current_level = 1

# Main game loop
def main():
    global current_scene, user_input, answer_feedback, math_question_active
    global current_question, lives, game_over, boost_active, boost_timer, camera_x
    global practice_question_index, questions_answered, water_rings, obstacles
    global show_theory, current_level, level_complete

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            elif event.type == pygame.MOUSEBUTTONDOWN:
                if current_scene == "menu":
                    mouse_pos = pygame.mouse.get_pos()
                    if start_button.collidepoint(mouse_pos):
                        current_scene = "level1"
                        reset_game()
                    elif practice_button.collidepoint(mouse_pos):
                        current_scene = "practice_hub"
                        practice_question_index = 0
                        show_theory = True

                elif current_scene == "practice_hub":
                    mouse_pos = pygame.mouse.get_pos()
                    for button in practice_hub_buttons:
                        if button["rect"].collidepoint(mouse_pos):
                            current_scene = button["target"]
                            practice_question_index = 0
                            show_theory = True

                elif current_scene in ["fractions_practice", "algebra_practice"]:
                    mouse_pos = pygame.mouse.get_pos()
                    back_btn = pygame.Rect(50, WINDOW_HEIGHT - 100, 150, 60)
                    next_btn = pygame.Rect(WINDOW_WIDTH - 200, WINDOW_HEIGHT - 100, 150, 60)
                    menu_btn = pygame.Rect(WINDOW_WIDTH//2 - 100, WINDOW_HEIGHT - 100, 200, 60)
                    toggle_btn = pygame.Rect(WINDOW_WIDTH//2 - 100, WINDOW_HEIGHT - 180, 200, 60)
                    
                    if back_btn.collidepoint(mouse_pos):
                        practice_question_index = max(0, practice_question_index - 1)
                    elif next_btn.collidepoint(mouse_pos):
                        max_index = len(fractions_practice)-1 if current_scene == "fractions_practice" else len(algebra_practice)-1
                        if practice_question_index < max_index:
                            practice_question_index = min(max_index, practice_question_index + 1)
                    elif menu_btn.collidepoint(mouse_pos):
                        current_scene = "menu"
                    elif toggle_btn.collidepoint(mouse_pos):
                        show_theory = not show_theory

                elif game_over:
                    yes_btn, no_btn = draw_game_over()
                    mouse_pos = pygame.mouse.get_pos()
                    if yes_btn.collidepoint(mouse_pos):
                        reset_game()
                        current_scene = "level1"
                    elif no_btn.collidepoint(mouse_pos):
                        current_scene = "menu"
                        game_over = False
                
                elif level_complete:
                    yes_btn, no_btn = draw_level_complete()
                    mouse_pos = pygame.mouse.get_pos()
                    if yes_btn.collidepoint(mouse_pos):
                        reset_game()
                        current_scene = "level1"
                    elif no_btn.collidepoint(mouse_pos):
                        current_scene = "menu"
                        level_complete = False

            elif event.type == pygame.KEYDOWN and current_scene == "level1" and math_question_active:
                if event.key == pygame.K_RETURN:
                    check_answer()
                elif event.key == pygame.K_BACKSPACE:
                    user_input = user_input[:-1]
                elif event.unicode.isdigit() or event.unicode in ["/", ".", "-"]:
                    user_input += event.unicode

        keys = pygame.key.get_pressed()
        if current_scene == "menu":
            draw_menu()
        elif current_scene == "practice_hub":
            draw_practice_hub()
        elif current_scene == "fractions_practice":
            draw_fractions_practice()
        elif current_scene == "algebra_practice":
            draw_algebra_practice()
        elif current_scene == "level1":
            if game_over:
                draw_game_over()
            elif level_complete:
                draw_level_complete()
            else:
                if not math_question_active:
                    handle_movement(keys)
                    check_obstacle_collision()
                check_ring_triggers()
                draw_level()

        pygame.display.flip()
        clock.tick(FPS)

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()